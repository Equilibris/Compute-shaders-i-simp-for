// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Render

#define length 60

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

uint WIDTH, HEIGHT;

float2 points[length];

float2 p2;
float2 p3;
float2 p4;
float2 p5;
float2 p6;
float2 p7;
float2 p8;
float2 p9;
float2 p10;
float2 p11;

float metaball (float2 center, float size, float2 pixelPossition, float mergeStrength = 0)
{
    return max((size + size * mergeStrength) / distance(center, pixelPossition) - mergeStrength, 0);
}

[numthreads(8, 8, 1)]
void Render (uint3 id : SV_DispatchThreadID)
{
    float2 p1 = float2(WIDTH / 2, HEIGHT/2);

    float2 pixelPossition = float2(id.xy);

    float smallSize = 1;
    float v = 1;

    float main = metaball(p1, 100, pixelPossition);

    float c = main, m = main, y = main;

    for(uint i1 = 0; i1 < length; i1+=3)
    {
        uint i2 = i1 + 1, i3 = i2 + 1;
        c += metaball(points[i1],  smallSize + 20 / (i1 + 1), pixelPossition);
        m += metaball(points[i2],  smallSize + 20 / (i2 + 1), pixelPossition);
        y += metaball(points[i3],  smallSize + 20 / (i3 + 1), pixelPossition);
    }

    Result[id.xy] = pow(c, 10) * float4(0,1,1,1) + pow(m, 5) * float4(1,0,1,1) + pow(y, 10) * float4(1,1,0,1) + 0.05;
}
